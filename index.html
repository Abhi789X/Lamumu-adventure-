<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Lamumu vs Bee â€” 30s Survival</title>
<style>
  :root{
    --bg1:#07202b; --bg2:#04232f; --card:#0b2736; --fg:#eef6ff;
    --muted:#9fb0c4; --accent:#7dd3fc; --lam:#facc15; --danger:#ef4444;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
  body{display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,var(--bg2),var(--bg1));color:var(--fg);padding:12px}
  .wrap{width:min(980px,96vw);max-width:980px;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));border-radius:12px;padding:12px;box-shadow:0 30px 90px rgba(0,0,0,0.6)}
  .top{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
  .title{font-weight:800;font-size:18px}
  .hud{display:flex;gap:10px;align-items:center}
  .badge{background:rgba(255,255,255,0.04);padding:6px 10px;border-radius:10px;font-weight:700}
  canvas{background:linear-gradient(180deg,#07323f,#04202c);border-radius:10px;border:1px solid rgba(255,255,255,0.03);display:block;touch-action:none}
  .controls{margin-top:10px;display:flex;gap:8px;align-items:center}
  .btn{background:linear-gradient(90deg,#3b82f6,#06b6d4);border:none;padding:10px 14px;border-radius:10px;color:white;font-weight:800;cursor:pointer}
  .small{color:var(--muted);font-size:13px}
  .modal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.55)}
  .modal.open{display:flex}
  .card{background:linear-gradient(180deg,#0f2435,#08121a);border-radius:14px;padding:20px;text-align:center;color:var(--fg);width:min(92%,520px);box-shadow:0 30px 90px rgba(0,0,0,0.6)}
  .replay{margin-top:14px;padding:10px 14px;border-radius:10px;border:none;background:linear-gradient(90deg,#34d399,#38bdf8);font-weight:800;color:#04202a;cursor:pointer}
  .hint{font-size:13px;color:var(--muted)}
  @media(max-width:760px){ .wrap{padding:8px} canvas{width:100%;height:auto} }
</style>
</head>
<body>
  <div class="wrap" role="application" aria-label="Lamumu vs Bee game">
    <div class="top">
      <div>
        <div class="title">Lamumu vs Bee</div>
        <div class="small">Draw barriers to protect the cow. Survive 30 seconds.</div>
      </div>
      <div class="hud">
        <div class="badge" id="timerBadge">Time: 30.0s</div>
        <div class="badge" id="levelBadge">Difficulty</div>
      </div>
    </div>

    <canvas id="game" width="960" height="600" aria-label="Lamumu vs Bee canvas"></canvas>

    <div class="controls">
      <button class="btn" id="startBtn">Start</button>
      <div class="hint" id="phaseHint">Start â†’ draw lines near the cow to block bees. Lines last a few seconds.</div>
    </div>
  </div>

  <div class="modal" id="endModal" role="dialog" aria-modal="true">
    <div class="card">
      <div id="endEmoji" style="font-size:44px">ðŸŽ‰</div>
      <div id="endTitle" style="font-weight:800;margin-top:8px">You Survived!</div>
      <div id="endText" style="color:var(--muted);margin-top:6px"></div>
      <button class="replay" id="restartBtn">Restart</button>
    </div>
  </div>

<script>
(() => {
  // ---------- CONFIG ----------
  const SURVIVE_TARGET = 30.0;           // seconds to survive
  const LINE_THICK = 8;
  const LINE_LIFE = 8.0;                 // seconds each line lasts
  const MAX_LINES = 6;                   // max concurrent barriers
  const SAMPLE_DIST = 6;                 // sampling distance for stroke points
  const COW_RADIUS = 30;
  const BEE_RADIUS = 9;
  const HIVE_POS = { x: 140, y: 80 };    // relative; we'll flip depending on difficulty
  const START_SPAWN_INTERVAL = 1.1;      // initial spawn interval
  const MIN_SPAWN_INTERVAL = 0.35;
  const START_BEE_SPEED = 60;
  const MAX_BEE_SPEED = 280;
  const MAX_BEES = 40;
  const DIFFICULTY_RAMP = 1.0 / SURVIVE_TARGET; // linear ramp per second

  // ---------- DOM ----------
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const startBtn = document.getElementById('startBtn');
  const phaseHint = document.getElementById('phaseHint');
  const timerBadge = document.getElementById('timerBadge');
  const levelBadge = document.getElementById('levelBadge');
  const endModal = document.getElementById('endModal');
  const endEmoji = document.getElementById('endEmoji');
  const endTitle = document.getElementById('endTitle');
  const endText = document.getElementById('endText');
  const restartBtn = document.getElementById('restartBtn');

  const W = canvas.width, H = canvas.height;
  const cowPos = { x: W/2, y: H - 90 }; // cow at ground center

  // ---------- STATE ----------
  let running = false;
  let timeLeft = SURVIVE_TARGET;
  let lines = []; // {points:[{x,y}], createdTime}
  let currentStroke = [];
  let isDrawing = false;
  let bees = []; // {x,y,vx,vy,r}
  let lastSpawn = 0;
  let spawnInterval = START_SPAWN_INTERVAL;
  let beeSpeed = START_BEE_SPEED;
  let startTime = 0;
  let audioCtx = null;
  let unlockedAudio = false;

  // ---------- AUDIO (WebAudio) ----------
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  function ensureAudio(){
    if(!audioCtx) audioCtx = new AudioCtx();
  }
  function playTone(freq=440, time=0.08, gain=0.06, type='sine'){
    try{
      if(!audioCtx) ensureAudio();
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type; o.frequency.value = freq;
      g.gain.value = gain;
      o.connect(g); g.connect(audioCtx.destination);
      o.start();
      g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + time);
      setTimeout(()=>{ try{o.stop()}catch(e){} }, time*1000+20);
    }catch(e){}
  }
  function beeBuzz(){ playTone(180,0.12,0.02,'square'); }
  function popSound(){ playTone(420,0.06,0.03,'sine'); }
  function stingSound(){ playTone(160,0.26,0.12,'sine'); }
  function winSound(){ playTone(520,0.12,0.06,'sine'); setTimeout(()=>playTone(680,0.08,0.05,'sine'),140); }

  // ---------- HELPERS ----------
  const clamp = (v,a,b) => Math.max(a,Math.min(b,v));
  const rnd = (a,b) => a + Math.random()*(b-a);
  const now = () => performance.now()/1000;

  function segDist(ax,ay,bx,by,px,py){
    const vx = bx-ax, vy = by-ay;
    const wx = px-ax, wy = py-ay;
    const c1 = vx*wx + vy*wy;
    if(c1 <= 0) return Math.hypot(px-ax, py-ay);
    const c2 = vx*vx + vy*vy;
    if(c2 <= c1) return Math.hypot(px-bx, py-by);
    const t = c1 / c2;
    const projx = ax + t*vx, projy = ay + t*vy;
    return Math.hypot(px-projx, py-projy);
  }

  function ccw(p1,p2,p3){ return (p3.y-p1.y)*(p2.x-p1.x) > (p2.y-p1.y)*(p3.x-p1.x); }
  function segmentsIntersect(a,b,c,d){
    return (ccw(a,c,d) !== ccw(b,c,d)) && (ccw(a,b,c) !== ccw(a,b,d));
  }

  // ---------- DRAW INPUT (pointer) ----------
  function toCanvasPos(e){
    const rect = canvas.getBoundingClientRect();
    const p = (e.touches && e.touches[0]) ? e.touches[0] : e;
    const x = (p.clientX - rect.left) * (canvas.width / rect.width);
    const y = (p.clientY - rect.top) * (canvas.height / rect.height);
    return {x,y};
  }

  canvas.addEventListener('pointerdown', (e)=>{
    if(!running) return;
    if(e.pointerType === 'mouse' && e.button !== 0) return;
    const p = toCanvasPos(e);
    // require start reasonably near cow (friendly)
    const d = Math.hypot(p.x - cowPos.x, p.y - cowPos.y);
    if(d > 220){ flashHint('Start near the cow'); return; }
    // begin stroke
    isDrawing = true;
    currentStroke = [{x:p.x, y:p.y}];
    e.preventDefault();
    if(!unlockedAudio){ ensureAudio(); unlockedAudio = true; }
  }, {passive:false});

  window.addEventListener('pointermove', (e)=>{
    if(!isDrawing) return;
    const p = toCanvasPos(e); const prev = currentStroke[currentStroke.length-1];
    const dx = p.x - prev.x, dy = p.y - prev.y;
    const d = Math.hypot(dx,dy);
    if(d < 3) return;
    const steps = Math.max(1, Math.floor(d / SAMPLE_DIST));
    for(let i=1;i<=steps;i++){
      const t = i/steps;
      currentStroke.push({x: prev.x + dx*t, y: prev.y + dy*t});
    }
  }, {passive:true});

  window.addEventListener('pointerup', ()=>{
    if(!isDrawing) return;
    finalizeStroke();
  });

  function finalizeStroke(){
    isDrawing = false;
    if(currentStroke.length < 2) { currentStroke = []; return; }
    if(lines.length >= MAX_LINES) lines.shift();
    lines.push({points: currentStroke.slice(), created: now()});
    popSound();
    currentStroke = [];
  }

  // ---------- BEES ----------
  function spawnBee(hiveX, hiveY, speed){
    if(bees.length >= MAX_BEES) return;
    // spawn slightly offset
    const angle = rnd(-0.8, 0.8) + Math.atan2(cowPos.y - hiveY, cowPos.x - hiveX);
    const sp = speed * rnd(0.9, 1.12);
    bees.push({ x: hiveX + rnd(-8,8), y: hiveY + rnd(-8,8), vx: Math.cos(angle)*sp, vy: Math.sin(angle)*sp, r: BEE_RADIUS });
    beeBuzz();
  }

  // reflect bee on any line segment collision
  function handleBeeLineCollision(b){
    for(const L of lines){
      const pts = L.points;
      for(let i=0;i<pts.length-1;i++){
        const a = pts[i], bb = pts[i+1];
        const d = segDist(a.x,a.y,bb.x,bb.y,b.x,b.y);
        if(d < b.r + 4){
          // normal
          const sx = bb.x - a.x, sy = bb.y - a.y;
          const len = Math.hypot(sx,sy) || 1;
          const nx = -sy/len, ny = sx/len;
          // push out
          b.x += nx*(b.r + 4 - d);
          b.y += ny*(b.r + 4 - d);
          // reflect
          const dot = b.vx*nx + b.vy*ny;
          b.vx = b.vx - 2*dot*nx; b.vy = b.vy - 2*dot*ny;
          b.vx *= 0.86; b.vy *= 0.86;
          popSound();
          return;
        }
      }
    }
  }

  // check if there exists any line blocking direct ray from bee to cow
  function rayBlockedByAnyLine(b){
    const A = {x: b.x, y: b.y}, B = {x: cowPos.x, y: cowPos.y};
    for(const L of lines){
      const pts = L.points;
      for(let i=0;i<pts.length-1;i++){
        if(segmentsIntersect(A,B, pts[i], pts[i+1])) return true;
      }
    }
    return false;
  }

  // ---------- GAME LOOP ----------
  let last = performance.now()/1000;
  function loop(){
    const nowT = performance.now()/1000;
    const dt = Math.min(0.033, nowT - last); last = nowT;

    if(running){
      // dynamic difficulty based on elapsed fraction
      const elapsed = SURVIVE_TARGET - timeLeft;
      const progress = clamp(elapsed / SURVIVE_TARGET, 0, 1);

      // adjust spawn interval & speed
      spawnInterval = START_SPAWN_INTERVAL * (1 - progress*0.7);
      spawnInterval = clamp(spawnInterval, MIN_SPAWN_INTERVAL, START_SPAWN_INTERVAL);
      beeSpeed = START_BEE_SPEED + (MAX_BEE_SPEED - START_BEE_SPEED) * progress;

      // spawn from hive(s) periodically
      lastSpawn += dt;
      if(lastSpawn >= spawnInterval){
        lastSpawn = 0;
        // choose hive side: alternate or random
        const hiveX = (Math.random() < 0.5) ? 140 : W - 140;
        const hiveY = 80 + rnd(-20,20);
        // spawn 1-2 bees based on progress
        const count = (Math.random() < 0.25 + progress*0.75) ? 2 : 1;
        for(let i=0;i<count;i++) spawnBee(hiveX, hiveY, beeSpeed);
      }

      // update bees
      for(let i=bees.length-1;i>=0;i--){
        const b = bees[i];

        // steer a bit toward cow (with jitter)
        const dirx = cowPos.x - b.x + rnd(-60,60) * (0.3 + progress*0.7);
        const diry = cowPos.y - b.y + rnd(-40,40) * (0.3 + progress*0.7);
        const len = Math.hypot(dirx,diry) || 1;
        const desiredVx = (dirx/len) * beeSpeed;
        const desiredVy = (diry/len) * beeSpeed;
        b.vx += (desiredVx - b.vx) * 0.04;
        b.vy += (desiredVy - b.vy) * 0.04;

        b.x += b.vx * dt;
        b.y += b.vy * dt;

        handleBeeLineCollision(b);

        // if close enough to cow, check if blocked
        const dCow = Math.hypot(b.x - cowPos.x, b.y - cowPos.y);
        if(dCow < COW_RADIUS + b.r - 2){
          // if ray is blocked by a line, cannot stab; else sting and lose
          if(!rayBlockedByAnyLine(b)){
            // STING -> game over
            running = false;
            showEnd(false);
            stingSound();
            return;
          } else {
            // bounce back a little
            b.vx *= -0.4; b.vy *= -0.4;
          }
        }

        // cull far away bees
        if(b.x < -120 || b.x > W+120 || b.y < -120 || b.y > H+120) bees.splice(i,1);
      }

      // update lines life and remove old ones
      const tNow = now();
      lines = lines.filter(L => (tNow - L.created) < LINE_LIFE);

      // update timer
      timeLeft -= dt;
      timerBadge.textContent = `Time: ${Math.max(0, timeLeft).toFixed(1)}s`;
      levelBadge.textContent = `Difficulty ${(Math.floor((1 - timeLeft/SURVIVE_TARGET)*100))}%`;

      if(timeLeft <= 0){
        running = false;
        showEnd(true);
        winSound();
        return;
      }
    }

    // draw frame
    draw();
    requestAnimationFrame(loop);
  }

  // ---------- DRAW ----------
  function draw(){
    // background
    const grad = ctx.createLinearGradient(0,0,W,H); grad.addColorStop(0,'#07323f'); grad.addColorStop(1,'#041a24');
    ctx.fillStyle = grad; ctx.fillRect(0,0,W,H);

    // distant hills
    ctx.fillStyle = '#0b2b2b';
    ctx.beginPath(); ctx.ellipse(W*0.2, H-160, 260, 90, 0, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(W*0.8, H-170, 220, 80, 0, 0, Math.PI*2); ctx.fill();

    // ground
    ctx.fillStyle = '#0b6b3a'; ctx.fillRect(0, H-90, W, 90);

    // draw hive(s)
    // left hive
    drawHive(140, 88);
    // right hive
    drawHive(W-140, 88);

    // draw lines
    ctx.lineWidth = LINE_THICK; ctx.lineCap = 'round'; ctx.lineJoin='round';
    ctx.strokeStyle = '#fffefc';
    for(const L of lines){
      const age = now() - L.created;
      const alpha = clamp(1 - (age / LINE_LIFE)*1.1, 0, 1);
      ctx.globalAlpha = alpha;
      ctx.beginPath();
      const pts = L.points; ctx.moveTo(pts[0].x, pts[0].y);
      for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;

    // draw current stroke
    if(currentStroke.length > 0){
      ctx.strokeStyle = '#ffffff';
      ctx.globalAlpha = 0.95;
      ctx.beginPath(); ctx.moveTo(currentStroke[0].x, currentStroke[0].y);
      for(let i=1;i<currentStroke.length;i++) ctx.lineTo(currentStroke[i].x, currentStroke[i].y);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    // draw bees
    for(const b of bees) drawBee(b);

    // draw cow in center base
    drawCow();

    // HUD overlay small
    ctx.fillStyle = 'rgba(255,255,255,0.04)'; ctx.fillRect(12,12,220,36);
  }

  function drawHive(x,y){
    ctx.save();
    ctx.fillStyle = '#f59e0b';
    ctx.beginPath(); ctx.ellipse(x, y, 40, 30, 0,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = '#78350f'; ctx.fillRect(x-16, y+6, 32, 12);
    ctx.fillStyle = '#fde047'; ctx.font = '12px system-ui'; ctx.fillText('Hive', x-18, y-36);
    ctx.restore();
  }

  function drawBee(b){
    ctx.save(); ctx.translate(b.x, b.y);
    ctx.beginPath(); ctx.fillStyle = '#fde047'; ctx.arc(0,0,b.r,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = '#111827'; ctx.fillRect(-b.r*0.34, -b.r*0.6, b.r*0.68, b.r*0.45);
    ctx.globalAlpha = 0.9; ctx.fillStyle = 'rgba(255,255,255,0.85)';
    ctx.beginPath(); ctx.ellipse(-b.r*0.62, -b.r*0.98, b.r*0.42, b.r*0.18, 0,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(b.r*0.12, -b.r*0.98, b.r*0.42, b.r*0.18, 0,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }

  function drawCow(){
    const cx = cowPos.x, cy = cowPos.y;
    // shadow
    ctx.save(); ctx.globalAlpha = 0.26; ctx.fillStyle = '#000'; ctx.beginPath(); ctx.ellipse(cx, cy+32, 44, 12, 0,0,Math.PI*2); ctx.fill(); ctx.restore();
    // body
    ctx.fillStyle = '#fffaf0'; ctx.fillRect(cx-42, cy-48, 84, 48);
    // spots
    ctx.fillStyle = '#111827'; ctx.fillRect(cx-16, cy-36, 16, 10); ctx.fillRect(cx+12, cy-28, 12, 8);
    // head
    ctx.fillStyle = '#fffaf0'; ctx.fillRect(cx+42, cy-44, 26, 22);
    ctx.fillStyle = '#111827'; ctx.fillRect(cx+50, cy-36, 5,5);
    ctx.fillStyle = '#f9a8d4'; ctx.fillRect(cx+44, cy-22, 12, 8);
    // legs
    ctx.fillStyle = '#e5e7eb'; ctx.fillRect(cx-36, cy+2, 12, 14); ctx.fillRect(cx+18, cy+2, 12, 14);
    // lamumu band
    ctx.fillStyle = 'var(--lam)'; ctx.fillRect(cx-42, cy-56, 84, 8);
    ctx.fillStyle = '#fde047'; ctx.fillRect(cx-2, cy-50, 10, 12);
  }

  // ---------- UI / EVENTS ----------
  function flashHint(text){
    const prev = phaseHint.textContent;
    phaseHint.textContent = text;
    setTimeout(()=>{ phaseHint.textContent = prev; }, 900);
  }

  function showEnd(won){
    endModal.classList.add('open');
    if(won){
      endEmoji.textContent = 'ðŸŽ‰';
      endTitle.textContent = 'Congrats â€” Lamumu Survived!';
      endText.textContent = `You protected Lamumu for ${SURVIVE_TARGET} seconds.`;
    } else {
      endEmoji.textContent = 'ðŸ’€';
      endTitle.textContent = 'Game Over â€” Lamumu got stung';
      endText.textContent = `Try again to protect Lamumu.`;
    }
  }

  startBtn.addEventListener('click', ()=>{
    if(!unlockedAudio) { try{ ensureAudio(); if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); unlockedAudio = true; }catch(e){} }
    // reset state
    lines = []; bees = []; timeLeft = SURVIVE_TARGET; running = true; lastSpawn = 0;
    startTime = now();
    endModal.classList.remove('open');
    timerBadge.textContent = `Time: ${timeLeft.toFixed(1)}s`;
    phaseHint.textContent = 'Draw barriers; lines last a few seconds.';
    // small start sound
    playTone(640,0.08,0.06,'sine');
  });

  restartBtn.addEventListener('click', ()=>{
    endModal.classList.remove('open');
    // restart fresh
    lines = []; bees = []; timeLeft = SURVIVE_TARGET; running = true; lastSpawn = 0;
    startTime = now();
    timerBadge.textContent = `Time: ${timeLeft.toFixed(1)}s`;
    phaseHint.textContent = 'Draw barriers; lines last a few seconds.';
  });

  // auto-unlock audio on first pointer
  document.addEventListener('pointerdown', function unlock(){
    try{ ensureAudio(); if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); }catch(e){}
    document.removeEventListener('pointerdown', unlock);
  });

  // ---------- START LOOP ----------
  let lastSpawn = 0;
  requestAnimationFrame(function tick(){
    last = performance.now()/1000;
    loop();
  });

  // small helper to play tone externally
  function playTone(f,t,g,type='sine'){ playTone; try{ if(!audioCtx) ensureAudio(); const o=audioCtx.createOscillator(); const gg=audioCtx.createGain(); o.type=type; o.frequency.value=f; gg.gain.value=g; o.connect(gg); gg.connect(audioCtx.destination); o.start(); gg.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + t); setTimeout(()=>{ try{o.stop()}catch(e){} }, t*1000+20);}catch(e){} }

  // Note: exported helper used earlier; fix small naming conflict
  function playTone(freq,time,gain,type='sine'){ try{ if(!audioCtx) ensureAudio(); const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type=type; o.frequency.value=freq; g.gain.value=gain; o.connect(g); g.connect(audioCtx.destination); o.start(); g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + time); setTimeout(()=>{ try{o.stop()}catch(e){} }, time*1000+20); }catch(e){} }

  // small housekeeping to ensure loop variable exists
  last = performance.now()/1000;
  function loop(){
    const nowT = performance.now()/1000;
    const dt = Math.min(0.033, nowT - last); last = nowT;

    if(running){
      // spawn timer & difficulty scaling
      lastSpawn += dt;
      const elapsed = SURVIVE_TARGET - timeLeft;
      const progress = clamp(elapsed / SURVIVE_TARGET, 0, 1);
      const curSpawn = clamp(START_SPAWN_INTERVAL * (1 - progress*0.75), MIN_SPAWN_INTERVAL, START_SPAWN_INTERVAL);
      if(lastSpawn >= curSpawn){
        lastSpawn = 0;
        // spawn from hive left or right or top (mix)
        const hSide = Math.random();
        let hx = (hSide < 0.45) ? 140 : (hSide < 0.9 ? W-140 : W*0.5);
        let hy = (hSide < 0.9) ? 80 : 40;
        // occasionally spawn cluster
        const cluster = Math.random() < 0.18 + progress*0.25;
        const count = cluster ? (2 + Math.floor(progress*2)) : 1;
        for(let i=0;i<count;i++) spawnBee(hx + rnd(-10,10), hy + rnd(-10,10), START_BEE_SPEED + (MAX_BEE_SPEED-START_BEE_SPEED)*progress);
      }

      // update bees
      for(let i=bees.length-1;i>=0;i--){
        const b = bees[i];
        // slight steering toward cow
        const dx = cowPos.x - b.x + rnd(-40,40)*progress;
        const dy = cowPos.y - b.y + rnd(-20,20)*progress;
        const len = Math.hypot(dx,dy)||1;
        const targetSpeed = START_BEE_SPEED + (MAX_BEE_SPEED-START_BEE_SPEED)*progress;
        const desiredVx = (dx/len)*targetSpeed;
        const desiredVy = (dy/len)*targetSpeed;
        b.vx += (desiredVx - b.vx) * 0.05;
        b.vy += (desiredVy - b.vy) * 0.05;

        b.x += b.vx * dt;
        b.y += b.vy * dt;

        handleBeeLineCollision(b);

        const dCow = Math.hypot(b.x - cowPos.x, b.y - cowPos.y);
        if(dCow < COW_RADIUS + b.r - 2){
          if(!rayBlockedByAnyLine(b)){
            running = false;
            showEnd(false);
            stingSound();
            return;
          } else {
            b.vx *= -0.35; b.vy *= -0.35;
          }
        }

        if(b.x < -120 || b.x > W+120 || b.y < -120 || b.y > H+120) bees.splice(i,1);
      }

      // prune old lines
      const tnow = now();
      lines = lines.filter(L => (tnow - L.created) < LINE_LIFE);

      // decrement timer
      timeLeft -= dt;
      timerBadge.textContent = `Time: ${Math.max(0,timeLeft).toFixed(1)}s`;
      levelBadge.textContent = `Difficulty: ${Math.round(progress*100)}%`;
      if(timeLeft <= 0){
        running = false;
        showEnd(true);
        winSound();
        return;
      }
    }

    draw();
    requestAnimationFrame(loop);
  }

  // small utility functions already defined above used here
  function rayBlockedByAnyLine(b){
    const A = {x: b.x, y: b.y}, B = {x: cowPos.x, y: cowPos.y};
    for(const L of lines){
      const pts = L.points;
      for(let i=0;i<pts.length-1;i++){
        if(segmentsIntersect(A,B, pts[i], pts[i+1])) return true;
      }
    }
    return false;
  }

  // final draw wrapper (overwrites previous draw due to scoping)
  function draw(){
    // simple background
    const g = ctx.createLinearGradient(0,0,W,H); g.addColorStop(0,'#07323f'); g.addColorStop(1,'#041a24');
    ctx.fillStyle = g; ctx.fillRect(0,0,W,H);

    // ground strip
    ctx.fillStyle = '#0b6b3a'; ctx.fillRect(0, H-90, W, 90);

    // draw hives
    drawHive(140, 88);
    drawHive(W-140, 88);

    // draw lines
    ctx.lineWidth = LINE_THICK; ctx.lineCap='round'; ctx.lineJoin='round';
    for(const L of lines){
      const age = now() - L.created;
      const alpha = clamp(1 - (age / LINE_LIFE), 0, 1);
      ctx.globalAlpha = alpha;
      ctx.strokeStyle = '#fffefc';
      ctx.beginPath();
      const pts = L.points; ctx.moveTo(pts[0].x, pts[0].y);
      for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;

    // draw current stroke
    if(currentStroke.length > 0){
      ctx.strokeStyle = '#ffffff'; ctx.globalAlpha = 0.95;
      ctx.beginPath(); ctx.moveTo(currentStroke[0].x, currentStroke[0].y);
      for(let i=1;i<currentStroke.length;i++) ctx.lineTo(currentStroke[i].x, currentStroke[i].y);
      ctx.stroke(); ctx.globalAlpha = 1;
    }

    // draw bees
    for(const b of bees) drawBee(b);

    // draw cow
    drawCow();

    // top-left overlay
    ctx.fillStyle = 'rgba(255,255,255,0.04)'; ctx.fillRect(12,12,260,36);
  }

  function drawHive(x,y){
    ctx.save();
    ctx.fillStyle = '#f59e0b';
    ctx.beginPath(); ctx.ellipse(x, y, 40, 30, 0,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = '#78350f'; ctx.fillRect(x-16, y+6, 32, 12);
    ctx.fillStyle = '#fde047'; ctx.font = '12px system-ui'; ctx.fillText('Hive', x-18, y-36);
    ctx.restore();
  }

  function drawBee(b){
    ctx.save(); ctx.translate(b.x, b.y);
    ctx.beginPath(); ctx.fillStyle = '#fde047'; ctx.arc(0,0,b.r,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = '#111827'; ctx.fillRect(-b.r*0.34, -b.r*0.6, b.r*0.68, b.r*0.45);
    ctx.globalAlpha = 0.88; ctx.fillStyle = 'rgba(255,255,255,0.85)';
    ctx.beginPath(); ctx.ellipse(-b.r*0.62, -b.r*0.98, b.r*0.42, b.r*0.18, 0,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(b.r*0.12, -b.r*0.98, b.r*0.42, b.r*0.18, 0,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }

  function drawCow(){
    const cx = cowPos.x, cy = cowPos.y;
    ctx.save();
    ctx.globalAlpha = 1;
    // shadow
    ctx.globalAlpha = 0.26; ctx.fillStyle = '#000'; ctx.beginPath(); ctx.ellipse(cx, cy+32, 44, 12, 0,0,Math.PI*2); ctx.fill(); ctx.globalAlpha = 1;
    // body
    ctx.fillStyle = '#fffaf0'; ctx.fillRect(cx-42, cy-48, 84, 48);
    // spots
    ctx.fillStyle = '#111827'; ctx.fillRect(cx-16, cy-36, 16, 10); ctx.fillRect(cx+12, cy-28, 12, 8);
    // head
    ctx.fillStyle = '#fffaf0'; ctx.fillRect(cx+42, cy-44, 26, 22);
    ctx.fillStyle = '#111827'; ctx.fillRect(cx+50, cy-36, 5,5);
    ctx.fillStyle = '#f9a8d4'; ctx.fillRect(cx+44, cy-22, 12, 8);
    // legs
    ctx.fillStyle = '#e5e7eb'; ctx.fillRect(cx-36, cy+2, 12, 14); ctx.fillRect(cx+18, cy+2, 12, 14);
    // lamumu band
    ctx.fillStyle = 'var(--lam)'; ctx.fillRect(cx-42, cy-56, 84, 8);
    ctx.fillStyle = '#fde047'; ctx.fillRect(cx-2, cy-50, 10, 12);
    ctx.restore();
  }

  // helper small functions used above
  function spawnBee(x,y,speed){
    if(bees.length >= MAX_BEES) return;
    const ang = Math.atan2((cowPos.y - y), (cowPos.x - x)) + rnd(-0.6, 0.6);
    const sp = speed * rnd(0.9, 1.15);
    bees.push({ x: x + rnd(-6,6), y: y + rnd(-6,6), vx: Math.cos(ang)*sp, vy: Math.sin(ang)*sp, r: BEE_RADIUS });
    beeBuzz();
  }

  // expose little sound wrappers used earlier
  function beeBuzz(){ try{ playTone(180,0.12,0.02,'square'); }catch(e){} }
  function popSound(){ try{ playTone(420,0.06,0.03,'sine'); }catch(e){} }
  function stingSound(){ try{ playTone(160,0.22,0.12,'sine'); }catch(e){} }
  function winSound(){ try{ playTone(520,0.12,0.06,'sine'); setTimeout(()=>playTone(680,0.08,0.05,'sine'),140); }catch(e){} }

  // start initial draw
  draw();
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>
