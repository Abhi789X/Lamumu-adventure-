<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<title>Protect the Cow â€” Lamumu Defender</title>
<style>
  :root{
    --bg-1:#071421; --bg-2:#072f3f; --card:#0b2736; --fg:#eef6ff;
    --muted:#9fb0c4; --accent:#7dd3fc; --lam:#facc15; --danger:#ef4444;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  body{display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,var(--bg-2),var(--bg-1));color:var(--fg);padding:12px}
  .wrap{width:min(1000px,96vw);max-width:1000px;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));border-radius:12px;padding:12px;box-shadow:0 30px 80px rgba(0,0,0,0.6)}
  .top{display:flex;align-items:center;justify-content:space-between;margin-bottom:8px}
  .title{font-weight:800;font-size:18px}
  .hud{display:flex;gap:10px;align-items:center}
  .badge{background:rgba(255,255,255,0.04);padding:6px 10px;border-radius:10px;font-weight:700}
  .board{display:flex;gap:12px;align-items:flex-start}
  canvas{background:linear-gradient(180deg,#0b2a3b,#06202b);border-radius:10px;border:1px solid rgba(255,255,255,0.03);touch-action:none}
  .controls{width:240px;display:flex;flex-direction:column;gap:10px}
  .btn{background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.08);padding:10px;border-radius:10px;color:var(--fg);font-weight:700;cursor:pointer}
  .barWrap{background:rgba(255,255,255,0.02);padding:8px;border-radius:10px}
  .bar{height:12px;background:rgba(255,255,255,0.04);border-radius:8px;overflow:hidden}
  .barFill{height:12px;background:linear-gradient(90deg,var(--accent),#60a5fa);width:0%}
  .hint{font-size:13px;color:var(--muted)}
  .modal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.5)}
  .modal.open{display:flex}
  .card{background:linear-gradient(180deg,#0f2435,#08121a);border-radius:14px;padding:20px;text-align:center;color:var(--fg);width:min(92%,520px);box-shadow:0 30px 90px rgba(0,0,0,0.6)}
  .replay{margin-top:14px;padding:10px 14px;border-radius:10px;border:none;background:linear-gradient(90deg,#34d399,#38bdf8);font-weight:800;color:#04202a;cursor:pointer}
  .small{font-size:13px;color:var(--muted)}
  @media(max-width:860px){ .board{flex-direction:column-reverse} .controls{width:100%} }
</style>
</head>
<body>
  <div class="wrap" role="application" aria-label="Protect the Cow game">
    <div class="top">
      <div>
        <div class="title">Protect the Cow â€” Lamumu Defender</div>
        <div class="small">Draw lines to shield the cow. Survive each level's target time.</div>
      </div>
      <div class="hud">
        <div class="badge" id="levelBadge">Level 1 / 5</div>
        <div class="badge" id="timeBadge">Time: 0.0s</div>
        <div class="badge" id="bestBadge">Best: 0</div>
      </div>
    </div>

    <div class="board">
      <canvas id="game" width="960" height="600" aria-label="Protect the Cow canvas"></canvas>

      <div class="controls" aria-hidden="false">
        <div class="barWrap">
          <div class="small">Ink</div>
          <div class="bar" style="margin-top:6px"><div class="barFill" id="inkFill"></div></div>
          <div class="small" id="inkText">0 / 0</div>
        </div>

        <button class="btn" id="clearBtn">Clear Lines</button>
        <button class="btn" id="muteBtn">Mute</button>
        <button class="btn" id="resetBtn">Reset Level</button>

        <div style="height:6px"></div>
        <div class="hint" id="hint">Tip: Start your stroke near the cow. Lines last a few seconds.</div>
        <div style="flex:1"></div>
        <div class="small">Controls: Draw with mouse or touch. Only a few active lines allowed.</div>
      </div>
    </div>
  </div>

  <div class="modal" id="endModal" role="dialog" aria-modal="true">
    <div class="card">
      <div id="endEmoji" style="font-size:40px">ðŸŽ‰</div>
      <div id="endTitle" style="font-weight:800;margin-top:8px">You Win!</div>
      <div id="endText" style="color:var(--muted);margin-top:6px"></div>
      <button class="replay" id="replayBtn">Replay</button>
    </div>
  </div>

<script>
(() => {
  // ===== CONFIG (tweakable) =====
  const LEVELS = 5;
  const LEVEL_TIMES = [4, 6, 8, 10, 12]; // seconds to survive
  const INK_PER_LEVEL = [1400, 1200, 1000, 900, 800]; // pixel length
  const LINE_LIFE = 3.4; // seconds
  const MAX_ACTIVE_LINES = 4;
  const SAMPLE_DIST = 6; // px between sample points on line
  const COW_RADIUS = 26;
  const BEE_RADIUS = 9;
  const START_BEE_SPEED = 70; // px/sec
  const BEE_SPEED_INC = 20; // per level
  const START_SPAWN_INTERVAL = 0.9; // secs
  const SPAWN_DECAY = 0.85; // spawn interval multiplier per level
  const MAX_BEES = 32;
  const SFX_ENABLED_DEFAULT = true;

  // ===== Setup canvas & UI =====
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;

  const inkFill = document.getElementById('inkFill');
  const inkText = document.getElementById('inkText');
  const levelBadge = document.getElementById('levelBadge');
  const timeBadge = document.getElementById('timeBadge');
  const bestBadge = document.getElementById('bestBadge');
  const hint = document.getElementById('hint');
  const endModal = document.getElementById('endModal');
  const endTitle = document.getElementById('endTitle');
  const endText = document.getElementById('endText');
  const endEmoji = document.getElementById('endEmoji');

  // ===== GAME STATE =====
  let levelIndex = 0;
  let inkLeft = 0;
  let totalInk = 0;
  let lines = []; // each: {points:[{x,y}], created:time, life}
  let currentStroke = [];
  let isDrawing = false;
  let strokesLenBuf = 0;
  let bees = []; // each bee: {x,y,vx,vy,r,alive}
  let lastSpawn = 0;
  let spawnInterval = START_SPAWN_INTERVAL;
  let beeSpeed = START_BEE_SPEED;
  let timeTarget = LEVEL_TIMES[0];
  let timeElapsed = 0;
  let running = false;
  let muted = !SFX_ENABLED_DEFAULT;
  let bestLevel = parseInt(localStorage.getItem('lamumu_best')||'0',10);
  bestBadge.textContent = `Best: ${bestLevel}`;

  // WebAudio for simple SFX
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  let audioCtx = null;
  function ensureAudio(){ if(!audioCtx) audioCtx = new AudioCtx(); }
  function playBuzz(vol=0.08, freq=120, dur=0.12){
    if(muted) return;
    ensureAudio();
    const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
    o.type='sine'; o.frequency.value = freq;
    g.gain.value = vol;
    o.connect(g); g.connect(audioCtx.destination);
    o.start(); g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + dur);
    setTimeout(()=>{ try{o.stop()}catch(e){} }, dur*1000);
  }
  function playPop(){ playBuzz(0.06,440,0.08); }
  function playHappy(){ if(muted) return; ensureAudio(); const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type='sine'; o.frequency.value=240; g.gain.value=0.08; o.connect(g); g.connect(audioCtx.destination); o.start(); setTimeout(()=>{ o.frequency.value=320; }, 120); setTimeout(()=>{ g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime+0.14); }, 300); setTimeout(()=>o.stop(),600); }
  function playHurt(){ playBuzz(0.12,80,0.22); }

  // ===== UTILITIES =====
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const rnd = (a,b)=>a + Math.random()*(b-a);
  const now = ()=>performance.now()/1000;

  // distance point->segment
  function segDist(a,b,p){
    const vx = b.x - a.x, vy = b.y - a.y;
    const wx = p.x - a.x, wy = p.y - a.y;
    const c1 = vx*wx + vy*wy;
    if(c1 <= 0) return Math.hypot(p.x - a.x, p.y - a.y);
    const c2 = vx*vx + vy*vy;
    if(c2 <= c1) return Math.hypot(p.x - b.x, p.y - b.y);
    const t = c1 / c2;
    const projx = a.x + t*vx, projy = a.y + t*vy;
    return Math.hypot(p.x - projx, p.y - projy);
  }

  // reflect velocity vector v across normal n (unit vector)
  function reflect(vx, vy, nx, ny){
    const dot = vx*nx + vy*ny;
    return {vx: vx - 2*dot*nx, vy: vy - 2*dot*ny};
  }

  // ===== GAME FUNCTIONS =====
  function startLevel(idx=0){
    levelIndex = clamp(idx,0,LEVELS-1);
    timeTarget = LEVEL_TIMES[levelIndex];
    totalInk = INK_PER_LEVEL[levelIndex];
    inkLeft = totalInk;
    lines = []; currentStroke = []; strokesLenBuf = 0;
    bees = []; lastSpawn = 0; timeElapsed = 0; running = true;
    spawnInterval = Math.max(0.25, START_SPAWN_INTERVAL * Math.pow(SPAWN_DECAY, levelIndex));
    beeSpeed = START_BEE_SPEED + BEE_SPEED_INC*levelIndex;
    levelBadge.textContent = `Level ${levelIndex+1} / ${LEVELS}`;
    updateInkUI();
    updateTimeUI();
    hint.textContent = `Survive ${timeTarget}s â€” Draw lines to block bees`;
    endModal.classList.remove('open');
    // unlock audio on first interaction policy
    canvas.focus();
  }

  function updateInkUI(){
    const pct = clamp(inkLeft/totalInk,0,1);
    inkFill.style.width = `${pct*100}%`;
    inkText.textContent = `${Math.round(inkLeft)} / ${totalInk}`;
  }
  function updateTimeUI(){
    const rem = Math.max(0, timeTarget - timeElapsed);
    timeBadge.textContent = `Time: ${rem.toFixed(1)}s`;
  }

  // spawn bee at random edge
  function spawnBee(){
    if(bees.length >= MAX_BEES) return;
    const side = Math.floor(Math.random()*4);
    let x,y;
    const pad = 20;
    if(side===0){ x = rnd(-20, W+20); y = -20; } // top
    else if(side===1){ x = W + 20; y = rnd(-20, H+20);} // right
    else if(side===2){ x = rnd(-20, W+20); y = H + 20;} // bottom
    else { x = -20; y = rnd(-20, H+20);} // left
    // optionally bias spawn toward cow for higher levels
    if(levelIndex >= 2 && Math.random()<0.4){
      // pick spawn near cow but off-screen
      const dir = Math.random()*Math.PI*2;
      x = clamp(W/2 + Math.cos(dir)*(Math.max(W,H)/2 + 80), -40, W+40);
      y = clamp(H/2 + Math.sin(dir)*(Math.max(W,H)/2 + 80), -40, H+40);
    }
    const angle = Math.atan2((H/2) - y, (W/2) - x) + rnd(-0.7, 0.7); // roughly toward center
    const speed = beeSpeed * rnd(0.85, 1.15);
    bees.push({x,y,vx:Math.cos(angle)*speed, vy:Math.sin(angle)*speed, r:BEE_RADIUS, life:999});
  }

  // sample stroke between two points with step SAMPLE_DIST
  function sampleAdd(prev, cur, arr){
    const dx = cur.x - prev.x, dy = cur.y - prev.y;
    const dist = Math.hypot(dx,dy) || 0.001;
    const steps = Math.floor(dist / SAMPLE_DIST);
    for(let i=1;i<=steps;i++){
      const t = i/steps;
      arr.push({x: prev.x + dx*t, y: prev.y + dy*t});
    }
  }

  // handle drawing input (pointer events)
  function toCanvasPos(e){
    const r = canvas.getBoundingClientRect();
    const p = (e.touches && e.touches[0]) ? e.touches[0] : e;
    const x = (p.clientX - r.left) * (canvas.width / r.width);
    const y = (p.clientY - r.top) * (canvas.height / r.height);
    return {x,y};
  }

  canvas.addEventListener('pointerdown', (ev)=>{
    ev.preventDefault();
    const p = toCanvasPos(ev);
    // require start near cow center (give generous radius)
    const dx = p.x - W/2, dy = p.y - H/2;
    const startDist = Math.hypot(dx,dy);
    if(startDist > 140){
      // allow if last lines near cow; but prefer to encourage start near cow
      hintFlash('Start near the cow!');
      return;
    }
    if(inkLeft <= 4){ hintFlash('Ink exhausted!'); return; }
    isDrawing = true;
    currentStroke = [{x: p.x, y: p.y}];
    strokesLenBuf = 0;
    ensureAudio();
    if(!muted) playPop(); // small draw sound
  }, {passive:false});

  window.addEventListener('pointermove', (ev)=>{
    if(!isDrawing) return;
    ev.preventDefault();
    const p = toCanvasPos(ev);
    const prev = currentStroke[currentStroke.length-1];
    const dx = p.x - prev.x, dy = p.y - prev.y;
    const d = Math.hypot(dx,dy);
    if(d < 3) return;
    // sample points at SAMPLE_DIST
    sampleAdd(prev, p, currentStroke);
    currentStroke.push({x: p.x, y: p.y});
    strokesLenBuf += d;
    // consume ink gradually; cap it
    if(strokesLenBuf >= SAMPLE_DIST){
      const use = Math.min(inkLeft, strokesLenBuf);
      inkLeft -= use;
      strokesLenBuf = 0;
      updateInkUI();
      if(inkLeft <= 0){ isDrawing = false; finalizeStroke(); hintFlash('Ink depleted'); }
    }
  }, {passive:false});

  window.addEventListener('pointerup', (ev)=>{
    if(!isDrawing) return;
    finalizeStroke();
  });

  function finalizeStroke(){
    if(currentStroke.length < 2) { currentStroke = []; return; }
    if(lines.length >= MAX_ACTIVE_LINES){ // remove oldest
      lines.shift();
    }
    lines.push({points: currentStroke.slice(), created: now(), life: LINE_LIFE});
    currentStroke = [];
    // small feedback
    if(!muted) playPop();
  }

  // remove expired lines
  function pruneLines(){
    const t = now();
    lines = lines.filter(L => (t - L.created) < L.life);
  }

  // reflect bees on lines
  function handleBeeLineCollision(bee){
    for(const L of lines){
      const pts = L.points;
      for(let i=0;i<pts.length-1;i++){
        const a = pts[i], b = pts[i+1];
        const d = segDist(a,b,bee);
        if(d < bee.r + 4){ // collision threshold
          // compute normal from segment
          const sx = b.x - a.x, sy = b.y - a.y;
          const len = Math.hypot(sx,sy) || 1;
          const nx = -sy/len, ny = sx/len; // perpendicular
          // push bee out
          bee.x += nx*(bee.r + 4 - d);
          bee.y += ny*(bee.r + 4 - d);
          // reflect vel with slight damp
          const out = reflect(bee.vx, bee.vy, nx, ny);
          bee.vx = out.vx * 0.9; bee.vy = out.vy * 0.9;
          // small pop sound
          if(!muted) playPop();
          return;
        }
      }
    }
  }

  // check bee->cow
  function checkBeeCow(bee){
    const dx = bee.x - W/2, dy = bee.y - H/2;
    const d = Math.hypot(dx,dy);
    return d < (bee.r + COW_RADIUS - 2);
  }

  // draw cow with mood
  let cowMood = 'neutral'; // 'neutral'|'happy'|'sad'
  let cowSadBumps = []; // positions for red bumps
  function drawCow(){
    const cx = W/2, cy = H/2;
    // shadow
    ctx.save(); ctx.globalAlpha = 0.24; ctx.fillStyle = '#000'; ctx.beginPath(); ctx.ellipse(cx, cy+30, 40, 12, 0, 0, Math.PI*2); ctx.fill(); ctx.restore();
    // body
    ctx.fillStyle = '#fffaf0'; ctx.fillRect(cx-36, cy-44, 72, 44);
    // spots
    ctx.fillStyle = '#111827'; ctx.fillRect(cx-20, cy-36, 14, 8); ctx.fillRect(cx+8, cy-28, 10, 6);
    // head
    ctx.fillStyle = '#fffaf0'; ctx.fillRect(cx+36, cy-40, 22, 18);
    // eye
    ctx.fillStyle = '#111827';
    if(cowMood==='happy'){ ctx.fillRect(cx+44, cy-34, 6, 6); ctx.fillStyle='#111827'; ctx.fillRect(cx+2, cy-32, 4, 4); }
    else if(cowMood==='sad'){ ctx.fillRect(cx+44, cy-34, 4, 4); ctx.fillStyle='#111827'; ctx.fillRect(cx+2, cy-32, 3, 3); }
    else { ctx.fillRect(cx+44, cy-34, 4, 4); ctx.fillRect(cx+2, cy-32, 3, 3); }
    // nose
    ctx.fillStyle = '#f9a8d4'; ctx.fillRect(cx+38, cy-24, 10, 6);
    // legs
    ctx.fillStyle = '#e5e7eb'; ctx.fillRect(cx-28, cy+2, 10, 12); ctx.fillRect(cx+16, cy+2, 10, 12);
    // lamumu band
    ctx.fillStyle = 'var(--lam)'; ctx.fillRect(cx-36, cy-52, 72, 8);
    ctx.fillStyle = '#fde047'; ctx.fillRect(cx-2, cy-48, 8, 10);
    // sad bumps
    if(cowMood === 'sad'){
      ctx.fillStyle = 'rgba(239,68,68,0.95)';
      for(const b of cowSadBumps){ ctx.beginPath(); ctx.ellipse(cx + b.x, cy + b.y, 6, 6, 0,0,Math.PI*2); ctx.fill(); }
    }
  }

  // draw bees
  function drawBee(b){
    ctx.save();
    ctx.translate(b.x, b.y);
    ctx.beginPath(); ctx.fillStyle = '#fde047'; ctx.arc(0,0,b.r,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = '#111827'; ctx.fillRect(-b.r*0.4, -b.r*0.6, b.r*0.8, b.r*0.5);
    // wings simple
    ctx.globalAlpha = 0.9; ctx.fillStyle = 'rgba(255,255,255,0.85)'; ctx.beginPath(); ctx.ellipse(-b.r*0.7, -b.r*0.9, b.r*0.45, b.r*0.2, 0,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(b.r*0.1, -b.r*0.9, b.r*0.45, b.r*0.2, 0,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }

  // draw lines & strokes
  function drawLines(){
    ctx.lineWidth = 8; ctx.lineCap='round'; ctx.lineJoin='round';
    for(const L of lines){
      const age = now() - L.created;
      const alpha = clamp(1 - (age / L.life), 0, 1);
      ctx.globalAlpha = 0.9 * alpha;
      ctx.strokeStyle = 'rgba(248,250,252,0.98)';
      ctx.beginPath();
      const pts = L.points;
      ctx.moveTo(pts[0].x, pts[0].y);
      for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y);
      ctx.stroke();
    }
    // current stroke
    if(currentStroke.length > 0){
      ctx.globalAlpha = 0.95;
      ctx.strokeStyle = 'rgba(248,250,252,0.98)';
      ctx.beginPath();
      ctx.moveTo(currentStroke[0].x, currentStroke[0].y);
      for(let i=1;i<currentStroke.length;i++) ctx.lineTo(currentStroke[i].x, currentStroke[i].y);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
  }

  // main draw
  function draw(){
    // background
    const g = ctx.createLinearGradient(0,0,W,H); g.addColorStop(0,'#072f3f'); g.addColorStop(1,'#061a22');
    ctx.fillStyle = g; ctx.fillRect(0,0,W,H);

    // decorative stars/texture
    ctx.save(); ctx.globalAlpha = 0.08;
    for(let i=0;i<40;i++){ const x=(i*97)%W; const y=(i*61)%H; ctx.fillStyle = (i%3? '#7dd3fc':'#e2e8f0'); ctx.fillRect(x+Math.sin(performance.now()*0.0006+i)*3, y, 2, 2); }
    ctx.restore();

    // draw lines
    drawLines();

    // draw bees
    for(const b of bees) drawBee(b);

    // draw cow in center
    drawCow();

    // UI overlay text small
    ctx.fillStyle = 'rgba(255,255,255,0.06)'; ctx.fillRect(12, 12, 260, 36);
  }

  // hints flash
  let hintTimer = null;
  function hintFlash(txt){
    const prev = hint.textContent;
    hint.textContent = txt;
    clearTimeout(hintTimer);
    hintTimer = setTimeout(()=>{ hint.textContent = prev; }, 900);
  }

  // ===== GAME LOOP =====
  let last = performance.now()/1000;
  function loop(){
    const nowT = performance.now()/1000;
    const dt = Math.min(0.033, nowT - last); last = nowT;

    if(running){
      // spawn logic
      lastSpawn += dt;
      if(lastSpawn >= spawnInterval){
        spawnBee(); lastSpawn = 0;
      }

      // prune lines
      pruneLines();

      // update bees
      for(let i = bees.length-1; i>=0; i--){
        const b = bees[i];
        // small random jitter to pathing
        const jitter = 0.9;
        const dirx = (W/2) - b.x + rnd(-jitter,jitter)*30;
        const diry = (H/2) - b.y + rnd(-jitter,jitter)*30;
        const len = Math.hypot(dirx,diry) || 1;
        const desiredVx = (dirx/len) * Math.hypot(b.vx, b.vy);
        const desiredVy = (diry/len) * Math.hypot(b.vx, b.vy);
        // slightly steer towards cow
        b.vx += (desiredVx - b.vx) * 0.04;
        b.vy += (desiredVy - b.vy) * 0.04;
        // clamp speed
        const spd = Math.hypot(b.vx, b.vy);
        const maxSpd = beeSpeed * (1 + (Math.random()*0.12 - 0.06));
        if(spd > maxSpd){
          b.vx = b.vx / spd * maxSpd;
          b.vy = b.vy / spd * maxSpd;
        }
        // integrate
        b.x += b.vx * dt; b.y += b.vy * dt;
        // collide with lines
        handleBeeLineCollision(b);
        // screen bounds bounce (soft)
        if(b.x < -60 || b.x > W+60 || b.y < -60 || b.y > H+60){
          // remove if off far away
          bees.splice(i,1); continue;
        }
        // check cow collision
        if(checkBeeCow(b)){
          // hit!
          running = false;
          cowMood = 'sad';
          // place red bumps randomly on cow
          cowSadBumps = [];
          const bumps = 4 + Math.floor(Math.random()*3);
          for(let k=0;k<bumps;k++) cowSadBumps.push({x: rnd(-18,18), y: rnd(-10,10)});
          playHurt();
          // show modal after small delay
          setTimeout(()=> {
            endEmoji.textContent = 'ðŸ’”';
            endTitle.textContent = 'Oh no â€” Cow got stung!';
            endText.textContent = `Level ${levelIndex+1} failed. Try again.`;
            endModal.classList.add('open');
            // store best
            localStorage.setItem('lamumu_best', String(Math.max(bestLevel, levelIndex)));
            bestLevel = Math.max(bestLevel, levelIndex);
            bestBadge.textContent = `Best: ${bestLevel}`;
          }, 450);
          break;
        }
      }

      // time update
      if(running){
        timeElapsed += dt;
        updateTimeUI();
        // win condition for level
        if(timeElapsed >= timeTarget){
          running = false;
          cowMood = 'happy';
          playHappy();
          // proceed next (or final)
          setTimeout(()=> {
            if(levelIndex < LEVELS - 1){
              levelIndex++;
              // show brief happy modal then reset
              endEmoji.textContent = 'ðŸ˜Š';
              endTitle.textContent = 'Level cleared!';
              endText.textContent = `Good job â€” loading next level...`;
              endModal.classList.add('open');
              // update best
              bestLevel = Math.max(bestLevel, levelIndex);
              localStorage.setItem('lamumu_best', String(bestLevel));
              bestBadge.textContent = `Best: ${bestLevel}`;
              setTimeout(()=>{ startLevel(levelIndex); }, 600);
            } else {
              // final win
              endEmoji.textContent = 'ðŸŽ‰';
              endTitle.textContent = 'Congratulations! Youâ€™re a true Lamumuion ðŸ®ðŸ˜';
              endText.textContent = `You cleared all ${LEVELS} levels!`;
              endModal.classList.add('open');
              // update best
              bestLevel = Math.max(bestLevel, levelIndex+1);
              localStorage.setItem('lamumu_best', String(bestLevel));
              bestBadge.textContent = `Best: ${bestLevel}`;
            }
          }, 350);
        }
      }
    }

    // draw
    draw();
    requestAnimationFrame(loop);
  }

  // ===== UI Hooks =====
  document.getElementById('clearBtn').addEventListener('click', ()=>{
    lines = []; currentStroke = []; inkLeft = totalInk; updateInkUI(); hintFlash('Cleared lines');
  });
  document.getElementById('resetBtn').addEventListener('click', ()=> startLevel(levelIndex));
  document.getElementById('muteBtn').addEventListener('click', ()=>{
    muted = !muted;
    document.getElementById('muteBtn').textContent = muted ? 'Unmute' : 'Mute';
  });
  document.getElementById('replayBtn').addEventListener('click', ()=>{
    endModal.classList.remove('open');
    startLevel(0);
  });

  // prevent page scroll while drawing on mobile
  canvas.addEventListener('touchstart', (e)=>{ e.preventDefault(); }, {passive:false});

  // start first level and game loop
  startLevel(0);
  requestAnimationFrame(loop);

  // auto resume audio on first user gesture to avoid Chrome autoplay block
  document.addEventListener('pointerdown', function unlockAudio(){
    try{ ensureAudio(); if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); }catch(e){}
    document.removeEventListener('pointerdown', unlockAudio);
  });

})();
</script>
</body>
</html>
