<!doctype html>

<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<title>Lamumu ‚Äî Paint The Path (Save the Cow)</title>
<style>
  :root{--bg:#071421;--card:#0b2736;--fg:#eef6ff;--muted:#9fb0c4;--accent:#7dd3fc;--lam:#facc15}
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial}
  body{display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,#031423,#071421);color:var(--fg);padding:14px}
  .wrap{width:min(980px,98vw);max-width:1000px;padding:12px;border-radius:12px;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));box-shadow:0 30px 80px rgba(0,0,0,0.6)}
  .top{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
  .title{font-weight:800;font-size:18px}
  .meta{color:var(--muted);font-size:13px}
  .hud{display:flex;gap:10px;align-items:center}
  .badge{background:rgba(255,255,255,0.04);padding:6px 10px;border-radius:10px;font-weight:700;color:var(--fg)}
  .board{display:flex;gap:12px;align-items:flex-start}
  canvas{background:linear-gradient(180deg,#0b2a3b,#06202b);border-radius:10px;border:1px solid rgba(255,255,255,0.03);touch-action:none}
  .controls{width:220px;display:flex;flex-direction:column;gap:10px}
  .btn{background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.08);padding:10px;border-radius:10px;color:var(--fg);font-weight:700;cursor:pointer}
  .btn:active{transform:translateY(1px)}
  .small{font-size:13px;color:var(--muted)}
  .barWrap{background:rgba(255,255,255,0.04);padding:8px;border-radius:10px}
  .bar{height:10px;background:rgba(255,255,255,0.06);border-radius:8px;overflow:hidden}
  .barFill{height:10px;background:linear-gradient(90deg,var(--accent),#60a5fa);width:0%}
  .hint{font-size:13px;color:var(--muted)}
  .modal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.5)}
  .modal.open{display:flex}
  .card{background:linear-gradient(180deg,#0f2435,#08121a);border-radius:14px;padding:20px;text-align:center;color:var(--fg);width:min(92%,520px);box-shadow:0 30px 90px rgba(0,0,0,0.6)}
  .replay{margin-top:14px;padding:10px 14px;border-radius:10px;border:none;background:linear-gradient(90deg,#34d399,#38bdf8);font-weight:800;color:#04202a;cursor:pointer}
  @media(max-width:800px){ .board{flex-direction:column-reverse} .controls{width:100%} }
</style>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <div>
        <div class="title">Lamumu ‚Äî Paint The Path</div>
        <div class="meta">Draw a path (limited ink). Cow will follow automatically. 5 levels. Mobile + PC.</div>
      </div>
      <div class="hud">
        <div class="badge" id="levelBadge">Level 1 / 5</div>
        <div class="badge" id="statusBadge">Draw a continuous path starting from the cow ‚Üí</div>
      </div>
    </div><div class="board">
  <canvas id="game" width="960" height="600" aria-label="Lamumu Paint The Path"></canvas>

  <div class="controls">
    <div class="barWrap">
      <div class="small">Ink</div>
      <div class="bar" style="margin-top:6px"><div class="barFill" id="inkFill"></div></div>
      <div class="small" id="inkText">0 / 0</div>
    </div>

    <button class="btn" id="clearBtn">Clear Path</button>
    <button class="btn" id="startBtn">Start Cow</button>
    <button class="btn" id="resetBtn">Reset Level</button>

    <div style="height:6px"></div>
    <div class="hint" id="hint">Tip: Begin your stroke near the cow. Path must reach the door. Limited ink per level.</div>
    <div style="flex:1"></div>
    <div class="small">Controls: Draw with mouse/finger. Press <strong>Start Cow</strong> to move.</div>
  </div>
</div>

  </div>  <div class="modal" id="winModal" role="dialog" aria-modal="true">
    <div class="card">
      <div style="font-size:40px">üéâ</div>
      <div style="font-weight:800;margin-top:8px">Congratulations! You‚Äôre a true Lamumuion üêÆüòç</div>
      <div style="color:var(--muted);margin-top:6px" id="winText">You cleared all 5 levels.</div>
      <button class="replay" id="replayBtn">Replay</button>
    </div>
  </div><script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;

  const levels = [
    // Each level: cow start, door rect, obstacles[], maxInk, tip
    {cow:{x:120,y:H-120}, door:{x:W-120,y:H-160,w:80,h:120}, obs:[{x:300,y:H-180,w:80,h:20},{x:520,y:H-260,w:80,h:20}], maxInk:1400, tip:'Draw a ramp from cow into the door.'},
    {cow:{x:110,y:H-120}, door:{x:W-160,y:H-260,w:80,h:120}, obs:[{x:250,y:H-220,w:120,h:20},{x:460,y:H-180,w:80,h:20},{x:700,y:H-300,w:80,h:20}], maxInk:1200, tip:'Door is higher ‚Äî make a curved chute.'},
    {cow:{x:140,y:H-120}, door:{x:W-200,y:H-320,w:80,h:120}, obs:[{x:320,y:H-240,w:120,h:20},{x:560,y:H-320,w:120,h:20},{x:820,y:H-240,w:80,h:20}], maxInk:1100, tip:'Zig-zag to gain/lose speed.'},
    {cow:{x:120,y:H-120}, door:{x:W-140,y:H-200,w:80,h:120}, obs:[{x:300,y:H-220,w:80,h:20},{x:480,y:H-260,w:80,h:20},{x:640,y:H-200,w:80,h:20}], maxInk:1000, tip:'Deflect and protect the cow from falling rocks.'},
    {cow:{x:140,y:H-120}, door:{x:W-140,y:H-320,w:80,h:120}, obs:[{x:260,y:H-260,w:100,h:20},{x:460,y:H-320,w:100,h:20},{x:680,y:H-260,w:100,h:20},{x:860,y:H-180,w:80,h:20}], maxInk:900, tip:'Final: precise funnel needed.'}
  ];

  let levelIndex = 0;
  let cow, door, obstacles, maxInk, inkUsed, pathSegments, drawing, currentStroke, pathReady, moving;
  let speed = 180; // cow pixels/sec along path
  let tpos = 0; // position along path (float index)

  function reset(lidx=0){
    levelIndex = Math.max(0, Math.min(lidx, levels.length-1));
    const L = levels[levelIndex];
    cow = {x:L.cow.x, y:L.cow.y, r:22};
    door = {x:L.door.x, y:L.door.y, w:L.door.w, h:L.door.h};
    obstacles = L.obs.map(o=>Object.assign({},o));
    maxInk = L.maxInk; inkUsed = 0; pathSegments = []; drawing = false; currentStroke = []; pathReady = false; moving = false; tpos = 0; speed = 180 + levelIndex*20;
    document.getElementById('levelBadge').textContent = `Level ${levelIndex+1} / ${levels.length}`;
    document.getElementById('statusBadge').textContent = L.tip;
    updateInkUI();
    draw();
  }

  function updateInkUI(){
    const pct = Math.max(0, 1 - inkUsed / maxInk);
    document.getElementById('inkFill').style.width = `${pct*100}%`;
    document.getElementById('inkText').textContent = `${Math.round(maxInk-inkUsed)} ink left`;
  }

  // Input handling (mouse + touch)
  function toCanvas(e){
    const rect = canvas.getBoundingClientRect();
    const cx = ((e.touches? e.touches[0].clientX : e.clientX) - rect.left) * (canvas.width/rect.width);
    const cy = ((e.touches? e.touches[0].clientY : e.clientY) - rect.top) * (canvas.height/rect.height);
    return {x:cx, y:cy};
  }

  canvas.addEventListener('pointerdown', (e)=>{
    if(moving) return; // no drawing while moving
    const p = toCanvas(e);
    // require stroke to start near cow (within 40 px)
    const d = Math.hypot(p.x - cow.x, p.y - cow.y);
    if(d > 80){ // allow a bit more forgiving
      // show hint flash
      flashHint('Start near the cow!');
      return;
    }
    drawing = true; currentStroke = [p];
  });
  window.addEventListener('pointermove', (e)=>{
    if(!drawing) return; const p = toCanvas(e);
    const prev = currentStroke[currentStroke.length-1];
    const segLen = Math.hypot(p.x-prev.x, p.y-prev.y);
    if(segLen < 2) return;
    if(inkUsed + segLen > maxInk){ // cut to remaining
      const allowed = Math.max(0, maxInk - inkUsed);
      if(allowed <= 1) { drawing=false; finalizeStroke(); return; }
      const ratio = allowed / segLen;
      const nx = prev.x + (p.x-prev.x)*ratio; const ny = prev.y + (p.y-prev.y)*ratio;
      currentStroke.push({x:nx,y:ny}); inkUsed += allowed; drawing=false; finalizeStroke(); updateInkUI(); return;
    }
    currentStroke.push(p); inkUsed += segLen; updateInkUI();
  });
  window.addEventListener('pointerup', ()=>{ if(drawing){ drawing=false; finalizeStroke(); } });

  function finalizeStroke(){
    if(currentStroke.length > 1){
      pathSegments.push(currentStroke.slice());
      // flatten path readiness if last point near door
      const last = currentStroke[currentStroke.length-1];
      if(pointInRect(last, door)) pathReady = true;
    }
    currentStroke = [];
    updateInkUI();
  }

  function pointInRect(p, r){ return p.x > r.x && p.x < r.x + r.w && p.y > r.y && p.y < r.y + r.h; }

  // Build a single polyline the cow will follow (concatenate segments)
  function buildPath(){
    const flat = [];
    for(const s of pathSegments) for(const pt of s) flat.push({x:pt.x,y:pt.y});
    // Simplify small distances
    const simp = [];
    for(const p of flat){ if(simp.length===0) simp.push(p); else { const prev=simp[simp.length-1]; if(Math.hypot(prev.x-p.x, prev.y-p.y) > 4) simp.push(p); }}
    return simp;
  }

  // Cow movement along path: walk along polyline by distance
  function moveCowAlong(path, dt){
    if(path.length < 2) return false;
    // tpos stores distance traveled in pixels
    let distanceToMove = speed * dt;
    while(distanceToMove > 0){
      // find segment index and local t
      let acc = 0; let found=false;
      for(let i=0;i<path.length-1;i++){
        const a=path[i], b=path[i+1]; const seg= Math.hypot(b.x-a.x, b.y-a.y);
        if(acc + seg >= tpos){
          // progress along this segment
          const segRemaining = acc + seg - tpos; const move = Math.min(distanceToMove, segRemaining);
          const t = ( (tpos - acc) + move ) / seg; const nx = a.x + (b.x-a.x)*t; const ny = a.y + (b.y-a.y)*t;
          cow.x = nx; cow.y = ny; tpos += move; distanceToMove -= move; found=true; break;
        }
        acc += seg;
      }
      if(!found){ // reached end
        tpos = acc; distanceToMove = 0; break;
      }
    }
  }

  function pathLength(path){ if(path.length<2) return 0; let s=0; for(let i=0;i<path.length-1;i++) s+=Math.hypot(path[i+1].x-path[i].x, path[i+1].y-path[i].y); return s; }

  function checkCollisions(){
    // cow collides with obstacles? if cow intersects any obs rect (body)
    for(const o of obstacles){ if(circleRectCollide(cow, o)) return true; }
    return false;
  }

  function circleRectCollide(c, r){
    const nx = clamp(c.x, r.x, r.x + r.w); const ny = clamp(c.y, r.y, r.y + r.h);
    return Math.hypot(c.x - nx, c.y - ny) < c.r - 2;
  }

  function draw(){
    // background
    const g = ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,'#072f3f'); g.addColorStop(1,'#061a22'); ctx.fillStyle=g; ctx.fillRect(0,0,W,H);

    // obstacles
    ctx.fillStyle='#07384a'; ctx.strokeStyle='rgba(255,255,255,0.04)'; for(const o of obstacles){ ctx.fillRect(o.x,o.y,o.w,o.h); ctx.strokeRect(o.x+0.5,o.y+0.5,o.w-1,o.h-1); }

    // door
    ctx.save(); ctx.fillStyle='#10b981'; ctx.fillRect(door.x, door.y, door.w, door.h); ctx.fillStyle='#064e3b'; ctx.fillRect(door.x+8, door.y+8, door.w-16, door.h-16); ctx.restore();

    // draw path segments
    ctx.lineWidth = 8; ctx.lineCap='round'; ctx.lineJoin='round'; ctx.strokeStyle = '#f8fafc';
    for(const s of pathSegments){ ctx.beginPath(); ctx.moveTo(s[0].x, s[0].y); for(let i=1;i<s.length;i++) ctx.lineTo(s[i].x, s[i].y); ctx.stroke(); }
    if(currentStroke.length>0){ ctx.beginPath(); ctx.moveTo(currentStroke[0].x, currentStroke[0].y); for(let i=1;i<currentStroke.length;i++) ctx.lineTo(currentStroke[i].x, currentStroke[i].y); ctx.stroke(); }

    // cow
    drawCow(cow.x, cow.y);

    // small UI elements
    ctx.fillStyle='#a8b3c2'; ctx.font='14px system-ui'; ctx.fillText(`Level ${levelIndex+1}/${levels.length}`, 18, 22);
  }

  function drawCow(x,y){
    const cx = x, cy = y;
    // shadow
    ctx.save(); ctx.globalAlpha = 0.25; ctx.fillStyle='#000'; ctx.beginPath(); ctx.ellipse(cx,cy+18,24,8,0,0,Math.PI*2); ctx.fill(); ctx.restore();
    // body
    ctx.fillStyle='#fffaf0'; ctx.fillRect(cx-20, cy-28, 40, 28);
    // spots
    ctx.fillStyle='#111827'; ctx.fillRect(cx-8, cy-22, 10, 8); ctx.fillRect(cx+6, cy-12, 8, 6);
    // head
    ctx.fillStyle='#fffaf0'; ctx.fillRect(cx+18, cy-20, 16, 14);
    ctx.fillStyle='#111827'; ctx.fillRect(cx+24, cy-14, 3,3);
    ctx.fillStyle='#f9a8d4'; ctx.fillRect(cx+20, cy-8, 6,4);
    // legs
    ctx.fillStyle='#e5e7eb'; ctx.fillRect(cx-16, cy, 6, 8); ctx.fillRect(cx+10, cy, 6, 8);
    // lamumu band
    ctx.fillStyle='#facc15'; ctx.fillRect(cx-20, cy-30, 40, 6);
    ctx.fillStyle='#fde047'; ctx.fillRect(cx-2, cy-24, 6, 8);
  }

  // flash a quick hint text
  let flashTimeout = null;
  function flashHint(txt){ const badge = document.getElementById('statusBadge'); const prev = badge.textContent; badge.textContent = txt; if(flashTimeout) clearTimeout(flashTimeout); flashTimeout = setTimeout(()=>{ badge.textContent = prev; }, 900); }

  // UI buttons
  document.getElementById('clearBtn').addEventListener('click', ()=>{ pathSegments = []; currentStroke = []; inkUsed = 0; updateInkUI(); pathReady = false; draw(); });
  document.getElementById('resetBtn').addEventListener('click', ()=>{ reset(levelIndex); });
  document.getElementById('startBtn').addEventListener('click', ()=>{
    if(moving) return; // already moving
    const fullPath = buildPath(); if(fullPath.length < 2){ flashHint('Draw a path first!'); return; }
    // ensure start of path is near cow
    const d0 = Math.hypot(fullPath[0].x - cow.x, fullPath[0].y - cow.y);
    if(d0 > 90){ flashHint('Path start must be near the cow.'); return; }
    // if path doesn't reach door, still allow but will fail
    moving = true; tpos = 0; pathReady = pointInRect(fullPath[fullPath.length-1], door); runMovement(fullPath);
  });

  // movement loop while moving true
  function runMovement(path){
    const dt = 1/60; // fixed
    const moveStep = ()=>{
      if(!moving) return;
      moveCowAlong(path, dt);
      // collision check
      if(checkCollisions()){ moving = false; flashHint('Cow hit an obstacle! Resetting level...'); setTimeout(()=> reset(levelIndex), 900); return; }
      // reached door?
      if(pointInRect({x:cow.x,y:cow.y}, door)){
        moving = false; levelIndex++; if(levelIndex < levels.length){ // next
          document.getElementById('statusBadge').textContent = 'Level cleared!'; setTimeout(()=> reset(levelIndex), 600);
        } else {
          // final win modal with only Replay button
          document.getElementById('winText').textContent = 'You cleared all 5 levels.'; document.getElementById('winModal').classList.add('open');
        }
        return;
      }
      draw(); requestAnimationFrame(moveStep);
    };
    requestAnimationFrame(moveStep);
  }

  document.getElementById('replayBtn').addEventListener('click', ()=>{ document.getElementById('winModal').classList.remove('open'); reset(0); });

  // initial
  reset(0);
  // render loop (for drawing updates)
  (function loop(){ draw(); requestAnimationFrame(loop); })();

})();
</script></body>
</html>      ball.x += ball.vx*dt; ball.y += ball.vy*dt;
      // collide with world bounds
      if(ball.x<ball.r){ball.x=ball.r; ball.vx*=-0.5}
      if(ball.x>W-ball.r){ball.x=W-ball.r; ball.vx*=-0.5}
      if(ball.y>H-ball.r){ball.y=H-ball.r; ball.vy*=-0.4}

      // collide with platforms
      for(const p of staticPlatforms){
        // platforms are rects {x,y,w,h}
        const nx = clamp(ball.x, p.x, p.x+p.w);
        const ny = clamp(ball.y, p.y, p.y+p.h);
        const d = Math.hypot(ball.x-nx, ball.y-ny);
        if(d < ball.r){
          // push out along normal
          const ang = Math.atan2(ball.y-ny, ball.x-nx);
          ball.x = nx + Math.cos(ang)*(ball.r+0.1);
          ball.y = ny + Math.sin(ang)*(ball.r+0.1);
          // reflect
          const nxv = Math.cos(ang), nyv = Math.sin(ang);
          const dot = ball.vx*nxv + ball.vy*nyv;
          ball.vx -= 1.6*dot*nxv; ball.vy -= 1.6*dot*nyv;
        }
      }
      // collide with drawn lines (treat as thick segments)
      for(const L of lines){
        for(let i=0;i<L.length-1;i++){
          const a=L[i], b=L[i+1];
          const d = segmentDistancePoint(a,b,ball);
          if(d < ball.r){
            // approximate normal as perpendicular to segment
            const sx=b.x-a.x, sy=b.y-a.y; const len=Math.hypot(sx,sy)||1; const nx = -sy/len, ny = sx/len;
            // push out
            const overlap = ball.r - d + 0.2; ball.x += nx*overlap; ball.y += ny*overlap;
            // reflect velocity
            const dot = ball.vx*nx + ball.vy*ny;
            ball.vx -= 1.8*dot*nx; ball.vy -= 1.8*dot*ny;
          }
        }
      }
    }

    function spawnBee(x,y){
      return {x,y,r:8,speed:110}
    }

    function stepBee(bee, dt){
      // try move toward cow
      const dir = Math.atan2(cow.y - bee.y, cow.x - bee.x);
      const step = {x: bee.x + Math.cos(dir)*bee.speed*dt, y: bee.y + Math.sin(dir)*bee.speed*dt};
      // blocked by drawn segments?
      let blocked=false;
      for(const L of lines){
        for(let i=0;i<L.length-1;i++){
          if(segmentsIntersect({x:bee.x,y:bee.y}, step, L[i], L[i+1])){ blocked=true; break; }
        }
        if(blocked) break;
      }
      if(!blocked){ bee.x = step.x; bee.y = step.y; }
      // check platforms as barriers (simple)
      for(const p of staticPlatforms){
        if(bee.x>p.x-bee.r && bee.x<p.x+p.w+bee.r && bee.y>p.y-6 && bee.y<p.y+p.h+6){
          // nudge back
          bee.x -= Math.cos(dir)*bee.speed*dt; bee.y -= Math.sin(dir)*bee.speed*dt;
        }
      }
      // hit cow?
      if(dist(bee, cow) < bee.r + 18){ lost = true; }
    }

    function makeLevels(){
      const basePlat = [
        {x:0,y:H-20,w:W,h:20}, // ground
      ];
      return [
        {
          cow:{x:140,y:H-40}, door:{x:W-90,y:H-110,w:40,h:80}, hive:{x:W/2,y:80},
          key:{x:80,y:120,vx:180,vy:0,r:10}, platforms:[...basePlat,{x:260,y:H-120,w:180,h:14}],
          len:1200, tip:'Shield cow from bees & ramp the key into the door ‚Üí'
        },
        {
          cow:{x:120,y:H-40}, door:{x:W-120,y:H-180,w:40,h:80}, hive:{x:W-240,y:90},
          key:{x:160,y:120,vx:130,vy:0,r:10}, platforms:[...basePlat,{x:340,y:H-180,w:160,h:14},{x:580,y:H-260,w:160,h:14}],
          len:1100, tip:'Higher door. Draw a chute.'
        },
        {
          cow:{x:160,y:H-40}, door:{x:W-160,y:H-260,w:40,h:80}, hive:{x:W/2,y:70},
          key:{x:120,y:90,vx:160,vy:0,r:10}, platforms:[...basePlat,{x:260,y:H-230,w:160,h:14},{x:500,y:H-310,w:160,h:14},{x:740,y:H-230,w:160,h:14}],
          len:1000, tip:'Zig-zag ramp needed.'
        },
        {
          cow:{x:120,y:H-40}, door:{x:W-120,y:120,w:40,h:80}, hive:{x:W-300,y:H-200},
          key:{x:W-840,y:80,vx:220,vy:0,r:10}, platforms:[...basePlat,{x:240,y:H-150,w:160,h:14},{x:520,y:H-220,w:160,h:14},{x:700,y:H-120,w:160,h:14}],
          len:950, tip:'Door is above‚Äîdraw walls to deflect.'
        },
        {
          cow:{x:140,y:H-40}, door:{x:W-140,y:120,w:40,h:80}, hive:{x:W/2+60,y:100},
          key:{x:90,y:70,vx:240,vy:0,r:10}, platforms:[...basePlat,{x:300,y:H-260,w:160,h:14},{x:540,y:H-320,w:160,h:14},{x:760,y:H-240,w:160,h:14},{x:880,y:200,w:120,h:14}],
          len:900, tip:'Final: protect + funnel perfectly.'
        }
      ];
    }

    function reset(idx=0){
      levels = makeLevels();
      levelIndex = Math.max(0, Math.min(idx, levels.length-1));
      const L = levels[levelIndex];
      cow = {x:L.cow.x, y:L.cow.y};
      door = {x:L.door.x, y:L.door.y, w:L.door.w, h:L.door.h, open:false};
      hive = {x:L.hive.x, y:L.hive.y, t:0};
      keyBall = {x:L.key.x, y:L.key.y, vx:L.key.vx, vy:L.key.vy, r:L.key.r};
      staticPlatforms = L.platforms.slice();
      lines = []; bees = [];
      totalDrawLen = 0; maxDrawLen = L.len;
      won=false; lost=false;
      document.getElementById('levelBadge').textContent = `Level ${levelIndex+1} / ${levels.length}`;
      document.getElementById('hintBadge').textContent = L.tip || '';
    }

    // ===== Drawing input (mouse & touch) =====
    function toCanvasXY(e){
      const rect = canvas.getBoundingClientRect();
      const x = (e.touches? e.touches[0].clientX : e.clientX) - rect.left;
      const y = (e.touches? e.touches[0].clientY : e.clientY) - rect.top;
      const sx = x * (canvas.width/rect.width);
      const sy = y * (canvas.height/rect.height);
      return {x:sx, y:sy};
    }

    function startDraw(e){ if(won||lost) return; drawing=true; currentLine=[]; const p=toCanvasXY(e); currentLine.push(p); e.preventDefault(); }
    function moveDraw(e){ if(!drawing) return; const p=toCanvasXY(e); const prev=currentLine[currentLine.length-1]; totalDrawLen += Math.hypot(p.x-prev.x, p.y-prev.y); if(totalDrawLen>maxDrawLen){ drawing=false; if(currentLine.length>1) lines.push(currentLine.slice()); return; } currentLine.push(p); e.preventDefault(); }
    function endDraw(){ if(!drawing) return; drawing=false; if(currentLine.length>1) lines.push(currentLine.slice()); currentLine=[]; }

    canvas.addEventListener('mousedown', startDraw); window.addEventListener('mousemove', moveDraw); window.addEventListener('mouseup', endDraw);
    canvas.addEventListener('touchstart', startDraw, {passive:false}); window.addEventListener('touchmove', moveDraw, {passive:false}); window.addEventListener('touchend', endDraw);

    // ===== Game loop =====
    let acc=0, last=performance.now();
    function loop(now){
      const dt = Math.min(0.033, (now-last)/1000); last=now; acc += dt;
      while(acc >= TIME_STEP){ step(TIME_STEP); acc -= TIME_STEP; }
      draw();
      requestAnimationFrame(loop);
    }

    function step(dt){
      if(won||lost) return;
      // spawn bees periodically
      hive.t += dt; if(hive.t>0.6){ hive.t=0; bees.push(spawnBee(hive.x, hive.y)); }
      // move bees
      for(const b of bees) stepBee(b, dt);
      // move key ball physics
      stepBall(keyBall, dt);
      // if key hits door, open & go next/win
      if( keyBall.x>door.x && keyBall.x<door.x+door.w && keyBall.y>door.y && keyBall.y<door.y+door.h ){
        door.open = true;
        // level progression
        if(levelIndex < levels.length-1){
          const txt = document.getElementById('winText'); txt.textContent = 'Level cleared! Next level loading‚Ä¶';
          document.getElementById('winModal').classList.add('open');
          setTimeout(()=>{ document.getElementById('winModal').classList.remove('open'); reset(levelIndex+1); }, 900);
        } else {
          // final
          won = true; document.getElementById('winText').textContent = 'You cleared all 5 levels.'; document.getElementById('winModal').classList.add('open');
        }
      }
      // if lost
      if(lost){ const txt = document.getElementById('winText'); txt.textContent = 'Cow got stung! Restarting level‚Ä¶'; document.getElementById('winModal').classList.add('open'); setTimeout(()=>{ document.getElementById('winModal').classList.remove('open'); reset(levelIndex); lost=false; }, 900); }
    }

    function draw(){
      // sky bg
      const g = ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,'#0b1e30'); g.addColorStop(1,'#071320'); ctx.fillStyle=g; ctx.fillRect(0,0,W,H);
      // stars
      ctx.save(); ctx.globalAlpha=0.2; for(let i=0;i<80;i++){ const x=(i*73)%W, y=(i*91)%H; ctx.fillStyle=(i%3?'#7dd3fc':'#e2e8f0'); ctx.fillRect(x+Math.sin(performance.now()*0.0006+i)*4, y, 2,2);} ctx.restore();

      // platforms
      for(const p of staticPlatforms){ ctx.fillStyle='#0e2236'; ctx.fillRect(p.x,p.y,p.w,p.h); ctx.strokeStyle='rgba(255,255,255,.06)'; ctx.strokeRect(p.x+0.5,p.y+0.5,p.w-1,p.h-1); }

      // door
      ctx.save(); ctx.fillStyle = door.open? '#22c55e':'#10b981'; ctx.fillRect(door.x,door.y,door.w,door.h); ctx.fillStyle = '#064e3b'; ctx.fillRect(door.x+6,door.y+6,door.w-12,door.h-12); ctx.restore();

      // hive
      ctx.save(); ctx.fillStyle='#f59e0b'; ctx.beginPath(); ctx.arc(hive.x,hive.y,16,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#78350f'; ctx.fillRect(hive.x-8,hive.y-4,16,8); ctx.restore();

      // bees
      ctx.fillStyle='#fde047'; for(const b of bees){ ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#111827'; ctx.fillRect(b.x-3,b.y-2,6,4); ctx.fillStyle='#fde047'; }

      // cow
      drawCow(cow.x, cow.y);

      // key ball
      ctx.save(); ctx.fillStyle='#93c5fd'; ctx.beginPath(); ctx.arc(keyBall.x,keyBall.y,keyBall.r,0,Math.PI*2); ctx.fill(); ctx.restore();

      // drawn lines
      ctx.lineWidth = 6; ctx.lineCap='round'; ctx.lineJoin='round';
      ctx.strokeStyle = '#e5e7eb';
      for(const L of lines){ ctx.beginPath(); ctx.moveTo(L[0].x,L[0].y); for(let i=1;i<L.length;i++) ctx.lineTo(L[i].x,L[i].y); ctx.stroke(); }
      if(currentLine.length>1){ ctx.beginPath(); ctx.moveTo(currentLine[0].x,currentLine[0].y); for(let i=1;i<currentLine.length;i++) ctx.lineTo(currentLine[i].x,currentLine[i].y); ctx.stroke(); }

      // draw lamumu length meter
      const used = Math.min(1, totalDrawLen/maxDrawLen);
      ctx.fillStyle='rgba(255,255,255,.08)'; ctx.fillRect(20,20,200,10); ctx.fillStyle='#7dd3fc'; ctx.fillRect(20,20,200*used,10); ctx.strokeStyle='rgba(255,255,255,.2)'; ctx.strokeRect(20.5,20.5,199,9);
      ctx.fillStyle='#a8b3c2'; ctx.font='12px system-ui, sans-serif'; ctx.fillText('Ink used', 20, 16);
    }

    function drawCow(x,y){
      const w=40,h=34; const cx=x, cy=y;
      // shadow
      ctx.save(); ctx.globalAlpha=.25; ctx.fillStyle='#000'; ctx.beginPath(); ctx.ellipse(cx, cy+12, 20, 6, 0, 0, Math.PI*2); ctx.fill(); ctx.restore();
      // body
      ctx.fillStyle='#f8fafc'; ctx.fillRect(cx-18,cy-26,36,26);
      // spots
      ctx.fillStyle='#111827'; ctx.fillRect(cx-8,cy-20,10,8); ctx.fillRect(cx+6,cy-12,8,6);
      // head
      ctx.fillStyle='#f8fafc'; ctx.fillRect(cx+16,cy-20,16,14);
      ctx.fillStyle='#111827'; ctx.fillRect(cx+22,cy-14,3,3);
      ctx.fillStyle='#f9a8d4'; ctx.fillRect(cx+18,cy-8,7,5);
      // legs
      ctx.fillStyle='#e5e7eb'; ctx.fillRect(cx-14,cy,6,6); ctx.fillRect(cx+6,cy,6,6);
      // Lamumu band
      ctx.fillStyle='#facc15'; ctx.fillRect(cx-14, cy-24, 28, 4);
      ctx.fillStyle='#fde047'; ctx.fillRect(cx-2, cy-20, 4, 6);
    }

    // Buttons
    document.getElementById('resetBtn').addEventListener('click', ()=> reset(levelIndex));
    document.getElementById('replayBtn').addEventListener('click', ()=> { document.getElementById('winModal').classList.remove('open'); reset(0); });

    // Start
    reset(0);
    requestAnimationFrame(loop);

  })();
  </script></body>
</html>
